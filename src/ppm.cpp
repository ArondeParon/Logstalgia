/*
    Copyright (C) 2009 Johannes Schindelin (johannes.schindelin@gmx.de)

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version
    3 of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ppm.h"
#include <assert.h>


extern "C" {
static int dumper_thread(void *arg) {
    FrameExporter *e = static_cast<FrameExporter *>(arg);

    e->dumpThr();

    return 0;
}
};

// FrameExporter

FrameExporter::FrameExporter() {

    //this now assumes the display is setup
    //before the frame exporter is created
    //(which seems reasonable)

    rowstride     = display.width * 3;

    pixels1        = new char[display.height * rowstride];
    pixels2        = new char[display.height * rowstride];

    pixels_shared_ptr = 0;

    screentex = display.emptyTexture(display.width, display.height, GL_RGBA);

	dumper_thread_state = FRAME_EXPORTER_WAIT;

    cond   = SDL_CreateCond();
    mutex  = SDL_CreateMutex();
    thread = SDL_CreateThread( dumper_thread, this );
}

FrameExporter::~FrameExporter() {

    if(dumper_thread_state != FRAME_EXPORTER_EXIT) {
        SDL_mutexP(mutex);

        dumper_thread_state = FRAME_EXPORTER_EXIT;

        SDL_CondSignal(cond);
        SDL_mutexV(mutex);
    }

    /* wait for thread to quit, then tear down */
    SDL_KillThread(thread);
    SDL_DestroyCond(cond);
    SDL_DestroyMutex(mutex);

    if(screentex!=0) glDeleteTextures(1, &screentex);

    pixels_shared_ptr = 0;

    delete[] pixels1;
    delete[] pixels2;
}

void FrameExporter::dump() {

    display.mode2D();

    glEnable(GL_TEXTURE_2D);
    glDisable(GL_BLEND);

    char* next_pixel_ptr = (pixels_shared_ptr == pixels1) ? pixels2 : pixels1;

    // copy pixels - now the right way up
    glReadPixels(0, 0, display.width, display.height,
        GL_RGB, GL_UNSIGNED_BYTE, next_pixel_ptr);

    // wait for lock before changing the pointer to point to our new buffer
    SDL_mutexP(mutex);

        //flip buffer we are pointing at
        pixels_shared_ptr = next_pixel_ptr;
        dumper_thread_state = FRAME_EXPORTER_DUMP;

    SDL_CondSignal(cond);
    SDL_mutexV(mutex);
}

void FrameExporter::dumpThr() {

    SDL_mutexP(mutex);

    for (;;) {
        while (dumper_thread_state == FRAME_EXPORTER_WAIT)
            SDL_CondWait(cond, mutex);

        if (dumper_thread_state == FRAME_EXPORTER_EXIT) break;

        if (pixels_shared_ptr != 0) {
            dumpImpl();

        }

        dumper_thread_state = FRAME_EXPORTER_WAIT;
    }

    SDL_mutexV(mutex);

}

// PPMExporter

PPMExporter::PPMExporter(std::string outputfile) {

    if(outputfile == "-") {
        output = &std::cout;

    } else {
        filename = outputfile;
        output   = new std::ofstream(outputfile.c_str(), std::ios::out | std::ios::binary);

        if(output->fail()) {
            delete output;
            throw PPMExporterException(outputfile);
        }
    }

    //write header
    sprintf(ppmheader, "P6\n# Generated by %s\n%d %d\n255\n",
        gSDLAppTitle.c_str(), display.width, display.height
    );

    pixels_out     = new char[display.height * rowstride];
}

PPMExporter::~PPMExporter() {
    SDL_mutexP(mutex);

        dumper_thread_state = FRAME_EXPORTER_EXIT;

        SDL_CondSignal(cond);

    SDL_mutexV(mutex);
    delete[] pixels_out;

    if(filename.size()>0)
        ((std::fstream*)output)->close();
}

void PPMExporter::dumpImpl() {
    int y_dst, y_src;
    *output << ppmheader;
    //invert image
    for(int y=0;y<display.height;y++) {
	y_dst = y * rowstride;
	y_src = (display.height - y - 1) * rowstride;
	memcpy(pixels_out + y_dst,pixels_shared_ptr + y_src, rowstride* sizeof(char));
    }
    output->write(pixels_out, rowstride * display.height);
}

// MPEGExporter

MPEGExporter::MPEGExporter(std::string outputfile):
    out_size(0), c(NULL)
{

    avcodec_init();
    avcodec_register_all();

    
    if(outputfile == "-") {
        output = &std::cout;

    } else {
        filename = outputfile;
        output   = new std::ofstream(outputfile.c_str(), std::ios::out | std::ios::binary);

        if(output->fail()) {
	    std::string msg = "can't open outfile \"";
	    msg += outputfile;
	    msg += "\"";
            delete output;	
            throw MPEGExporterException(msg);
        }
    }

    codec = avcodec_find_encoder(CODEC_ID_MPEG1VIDEO);
    if (!codec) {
        delete output;
        throw MPEGExporterException("codec not found");
    }

    c = avcodec_alloc_context3(codec);
    picture= avcodec_alloc_frame();
    picture_yuv= avcodec_alloc_frame();

    /* put sample parameters */
    c->bit_rate = 400000;
    assert(display.width % 2 == 0);
    assert(display.height % 2 == 0);
    c->width = display.width;
    c->height = display.height;
    /* frames per second */
    c->time_base= (AVRational){1,25};
    c->gop_size = 10; /* emit one intra frame every ten frames */
    c->max_b_frames=1;
    c->pix_fmt = PIX_FMT_YUV420P;

    /* open it */
    if (avcodec_open(c, codec) < 0) {
        delete output;
        throw MPEGExporterException("could not open codec");
    }
    img_convert_ctx = sws_getContext(
	    display.width, display.height, PIX_FMT_RGB24, 
	    display.width, display.height, PIX_FMT_YUV420P, 
	    SWS_CPU_CAPS_MMX|SWS_CPU_CAPS_MMX2|SWS_CPU_CAPS_3DNOW|
	    SWS_FAST_BILINEAR,
	    NULL, NULL, NULL);
    outbuf = (uint8_t*)malloc(MPEG_BUF_SIZE);

    printf("%d, %d\n", c->width, c->height);
    avpicture_alloc((AVPicture *)picture, PIX_FMT_RGB24, c->width, c->height);
    avpicture_alloc((AVPicture *)picture_yuv, PIX_FMT_YUV420P, c->width, c->height);
}

MPEGExporter::~MPEGExporter() {
	
    SDL_mutexP(mutex);

        dumper_thread_state = FRAME_EXPORTER_EXIT;

        SDL_CondSignal(cond);

    SDL_mutexV(mutex);

    while(out_size){
    	out_size = avcodec_encode_video(c, outbuf, MPEG_BUF_SIZE, NULL);
    	output->write((char*)outbuf, out_size);
    }

    avcodec_close(c);
    av_free(c);
    av_free(picture->data[0]);
    av_free(picture_yuv->data[0]);
    av_free(picture);    
    av_free(picture_yuv);

    if(filename.size()>0){
    	outbuf[0] = 0x00;
    	outbuf[1] = 0x00;
    	outbuf[2] = 0x01;
    	outbuf[3] = 0xb7;
    	output->write((char*)outbuf, 4);
        ((std::fstream*)output)->close();
    }
    free(outbuf);
}

void MPEGExporter::dumpImpl() {
    uint8_t *data = picture->data[0];
    int y_src, y_dst;
    for(int y=0;y<display.height;y++) {
	y_dst = y * rowstride;
	y_src = (display.height - y - 1) * rowstride;
	memcpy(data + y_dst,pixels_shared_ptr + y_src, rowstride* sizeof(char));
    }
    sws_scale(img_convert_ctx, picture->data, picture->linesize,  0, c->height, picture_yuv->data, picture_yuv->linesize);
    out_size = avcodec_encode_video(c, outbuf, MPEG_BUF_SIZE, picture_yuv);
    output->write((char*)outbuf, out_size);

}
